# SYSCLKINIT

说明：这篇总结是用来说明单片机在上电的时候，运行在main函数之前的systeminit()函数，主要作用是确定系统的时钟频率，各个总线时钟频率。开启协处理器。设置向量表的偏移地址。

单片机的工作需要时钟系统，为什么需要时钟系统？

因为计算机在执行一条指令时，需要节拍。操作寄存器的时候需要有一个脉冲变化，比如有些寄存器，只能在上升沿写入数据。如果没有这个时钟频率。计算机内部就没有一个统一的时间，各个部件之间没有一个前后顺序，信息就会被打乱。一条指令不知道该什么时候开始，什么时候结束。两个部件之间没有一个统一的频率，无法协调工作。寄存器的操作没有一个标准。什么情况下，去读，什么情况下去写。操作的过程，需要多长时间。这些问题都成为未定义的了。想怎么做就怎么。这样是无法工作的。

所以计算机系统中需要有时钟系统。

在单片机中，时钟系统的配置就十分重要了。

在它的启动文件中，有这么一段代码：

```assembly
Reset_Handler   PROC
                EXPORT  Reset_Handler                       [WEAK]
                IMPORT  __main
                IMPORT  SystemInit
                LDR     R0, =SystemInit
                BLX     R0
                LDR     R0, =__main
                BX      R0
                ENDP
;这一段代码表示初始化单片机的硬件资源，其中的systeminit函数就是配置单片机的时钟系统
;为接下来的工作提供了一个时序脉冲
            
```

然后开始编写时钟系统，先使用HSI作为系统时钟：

这个过程就非常简单了，观察时钟框图，只要使能HSI,设置它成为系统时钟源就OK了。下面是我的代码：

```c
void system_init(void)
{
	//先使能HSI
	RCC->CTRL |= HSIEN_BIT;
	//清除一些配置位
	//RESET SYSCLKSEL AHBPSC APB1PSC APB2PSC
	//RESET HSEEN PLLEN HSEBYPS 
	//RESET LSISTBLFC LSE HSI HSE PLL HSECFDFC
	RCC->CFG &= ~(SYSCLK_Mask | AHBPSC_Mask | APB1PSC_Mask | APB2PSC_Mask);
	RCC->CTRL &= ~(HSEEN_Mask | HSEBYPS_Mask | PLLEN_Mask);

}

void sysclk_HSIEN(void)
{
	system_init();
	RCC->CFG |= SYSCLKSEL_HSI;
	RCC->CFG |= SYSCLK_1 | HCLK_1;
}
//通过代码可以看到，在函数的开头，先使能时钟系统。让单片机的工作有一个时序脉冲，然后再进行我们后续的配置。
//先清除一些我们后续会用到的一些位，
//然后设置系统时钟源
//接下来设置各总线的分频系数
```

​	看上面的配置，很简单。但是在我写完上述代码后，编译，下载。

​	现象：无反应！

​	为了查看效果，我用led灯的闪烁来验证。延时500毫秒。

​	但是现在无反应。

​	怀疑：是时钟没有开启吗？还是led没有使能时钟？

​	结果：经过排查代码，发现没有设置分频系数，为缺省值。分频系数不确定。

​	修改代码，确定分频系数，编译下载。

​	现象：无反应。

​	怀疑：还有其他细节我没有考虑到。

​	处理：把官方库时钟源码从头到尾分析了一下，发现官方库在开启时钟之前，还干了一件事，那就是配置协处理器的访问权限。配置为full access。

​	疑惑：为什么要开启协处理？

​	原因：到网上查了一下。说是在初始化ARM处理器的时候，还有就是一些特殊的运算，CPU无法独立完成，需要一些协处理器来帮助它，所以需要开启协处理器的访问权限。

​	然后在代码中添加开启协处理器访问权限的代码，编译，下载。

​	现象：LED成功闪烁。

​	分析：利用逻辑分析仪抓取波形，延时500毫秒，实际延时495毫秒，然后观察延时100毫秒，实际延时98毫秒。误差还是比较大的。

​	HSI的时钟源已经成功了，接下就是HSE的时钟了。

​	在使用HSE的时钟之前，要先开启HSI,这么说吧，单片机在上电后开启的第一时钟源，只能是HSI。然后，在这个时钟频率下，再进行其他的配置。

​	同样的，查看手册，编写代码:

```c
void sysclk_HSEEN(void)
{
	//先使能外部高速时钟
	//切换系统时钟源
	//关闭内部高速时钟
	system_init();
	RCC->CTRL |= HSEEN_BIT;
	
	do{
		
	}while((RCC->CTRL & HSESTBL_FLAG) == 0 );
	
	RCC->CFG |= SYSCLK_1 | HCLK_1;
		
	RCC->CFG |= SYSCLKSEL_HSE;
	RCC->CTRL &= ~HSIEN_BIT;

}
//通过代码，发现多了一个do。。。while出口条件循环。
//条件是：当外部时钟准备就绪时，结束循环。
//因为时钟在开启后，不是直接就到指定频率的，而是有一个过程。从0到8M的频率。
//如果没有等待，开启后，直接切换时钟源，会造成一段时间内处理器的速度波动很大，有可能会出错。尽管这个时间段很短。
//为了验证确定使用的时外部时钟，在切换系统时钟源之后，将HSI时钟关闭。
```

​	HSE的时钟代码，很简单，在HSI时钟成功之后，HSE代码，一次通过，下载之后，一次成功闪烁。

​	现象：led闪烁。

​	分析：用逻辑分析仪抓取波形，延时500毫秒，实际延时500.009毫秒，很精准，比HSI的时钟精准了好多。

​	到这里，我们看到，单片机的内部时钟，在上电后第一时间开启，然后切换到外部时钟。因为内部时钟不够精准，所以我们一般采用外部时钟源来给CPU提供时钟频率，保证工作处在一个稳定的频率下。

​	最后，就是PLL的时钟，这个时钟相对于HSI和HSE 来说，稍微麻烦了一点，麻烦在什么地方呢，不是什么算法，就是多了几个寄存器。

​	先看我编译成功之后的代码，稍后说明过程中出现的错误。

```c
void sysclk_PLLEN(uint32_t PLLCLK_MUL)
{
	//使能HSE时钟
	//稳定之后，确定各总线的分频系数
	//选择PLL的倍频系数
	//使能PLL时钟
	system_init();
	RCC->CTRL |= HSEEN_BIT;
	
	do{
		
	}while((RCC->CTRL & HSESTBL_FLAG) == 0);
	
	RCC->CFG |= SYSCLK_1;
	RCC->CFG |= APB1CLK_DIV_2;
	RCC->CFG |= APB2CLK_DIV_2;
	
	RCC->CFG &= ~PLLCLK_Mask;
	RCC->CFG |= PLLCLK_MUL;
	RCC->CFG |= PLLSRC_HSE;
//RCC->CFG &= ~PLLSRC_HSI;

	RCC->CFG |= PLLRANGE_GR72MHz;
	
	RCC->CTRL |= PLLEN_BIT;
	do{
		
	}while((RCC->CTRL & PLLSTBL_FLAG) == 0);
	
	RCC->CFG |= SYSCLKSEL_PLL;
	
}

```

​	这一段代码，配置的寄存器比较多一点。过程回放：guan

​	编译，下载。

​	现象：延时500毫秒，初步观察led的闪烁，明显不对。

​	分析：利用逻辑分析仪，抓取波形，延时500毫秒，实际延时765毫秒。

​	怀疑：PLL的输出波形，不对。为什么会不对，倍频系数不对。

​	处理：从头检查PLL函数代码，重新计算倍频系数。为了保证正确，查看官方库的定义，一样。

​	倍频系数没有错，难道时当它作为PLL的时钟时，被分频了吗？重新查看手册，当HSI作为PLL的时钟源时会被二分频，但是HSE作为PLL的时钟源时，可以选择不分频，或者时二分频。我采用的是缺省值，不确定。然后修改代码，配置RCC->CFG的第十七位，确定当HSE作为PLL时钟源时，输入的频率。

​	编译，运行，下载。

​	现象：还是一样，延时500毫秒，实际延时765毫秒。

​	怀疑：肯定是有什么地方没有配置到，重新打开手册，查看RCC->CFG寄存器，时钟配置寄存器。发现了这个一个位，它的最高位：PLLRANGE,PLL clock的输出范围，不大于72M的需要将该为置零，大于72M需要置一。

​	处理：难道是这个位的原因吗，我修改代码，将这一个位置一。

​	编译，下载。

​	现象：用肉眼观察led的闪烁频率，比上一次短了，具体是多少，还得靠逻辑分析仪抓波形。打开逻辑分析仪，抓取波形，延时500毫秒，实际延时499.995毫秒，延时精准。

​	到这里，HSI,HSE和PLL的程序就完成了，但是有一个问题，就是在使用PLL函数时，它是将HSE的时钟进行倍频输出，这个倍频的系数，应该是可以选的，而不是一个固定的频率。所以我采用宏定义的方式，将手册中列出来的倍频系数，都定义了。在调用的时候只需要传入相应的宏定义就好了。

最后就是SystemCoreClock这个宏定义的值，它的值应该是当前系统使用的时钟频率。在这里我把它定义成全局变量，只能在HSI,HSE和PLL这三个函数中进行修改它的置，其他地方只能使用不能修改，添加前缀：const，保证SystemCoreClock的值不会被意外修改。

​	另外，在RCC->CFG寄存器中，还有一些其他的分频配置，比如ADC,USB,对外输出频率，都可以通过这个寄存器进行配置，如果程序中需要用到这些功能，就需要在这里提前配置好。

