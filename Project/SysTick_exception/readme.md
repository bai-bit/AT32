# Systick_exception

​		通过查看启动文件，发现SysTick中断属于内核中断，不用设置NVIC。

​		通过查看cotex-M4内核数据手册，将SysTick->CSR寄存器的第二位置一，就可以使能SysTick中断。

​		然后查看启动文件，查看SysTick中断的处理函数符号，然后用该符号作为中断处理函数名，写一个函数。

​		在技术大牛的指点下，写了一个利用SysTick中断，向电脑每隔100ms打印一个数字，打印一次，数值自增1。

​		出现的问题：串口调试助手的窗口无反应。

​			排查：首先是串口调试助手的串口开关打开，波特率正确。硬件连接正常。

​			向板子发送字符无反应。

​			怀疑原因：延时函数出现问题了。

​			排查：注释掉串口代码。在while（1）里边写了一个led闪烁。

​			现象：led常亮，延时函数出现问题。排查延时函数的代码。包括delayinit，delayms，delayus。

​			原因：在检查delayinit函数时，发现传递的参数不对。应该是我自己定义的宏定义：

```c
#define SYSTICK_SOURCE SystemCoreClock
```

​			或者是getclock_frrquency的返回值。但是这个时候，delayinit的参数不是这两个。编译也没有提示错误。

​			修改代码，重新编译。下载hex文件。led灯成功闪烁。用逻辑分析仪查看波形，延时是否精准，延时500ms，实际是0.49995s。误差可以接受。

​			取消串口代码的注释，把led的代码注释掉。编译，下载hex文件。打开串口调试助手，成功显示不断递增的数值