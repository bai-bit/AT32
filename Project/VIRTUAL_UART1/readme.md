# 写模拟串口代码的思路和过称

​	如题：写一个串口的收发代码，配置好串口的寄存器，就可以使用了。但是如果用IO口来模拟串口的收发，那样的话，怎么来做，有这么几个问题需要考虑：

​	1、串口的波形怎么来实现？

​	2、什么时候是接受数据，什么时候发送数据？

​	3、波特率怎么来实现？

​	4、串口的数据是一个字节一个字节发送，模拟串口怎么来实现？

​	现在我来回答这些问题：

​	1、利用IO的高低电平加延时函数来模拟串口的波形。

​	2、收发数据的时刻：和串口的方式一样，采用中断触发接收数据，在接受完成后，根据需求，完成发送。

​	3、波特率的实现，我个人的理解：波特率就是使用串口通信的双方，约定在单位时间内，发送多少个有效数据位，通过逻辑分析仪，其实就是在单位时间内，接收方对接收的波形进行采样了多少次，这个次数，就是波特率。并且再一个字节数据中，每次采样的时间间隔尽可能的一致，保证数据的准确性。

​	那么怎么来实现波特率呢，我的办法是：在使用IO口模拟串口中，采用延时函数来实现波特率。

​	4、串口数据的发送：将要发送的数据拆开，彻底拆开，拆成一位一位的，然后再发送。

​	在开始，我的思路就是这样的。然后开始在MDK上搭建框架。很快我就遇到了新的问题：

​	__采用中断才发方式，来唤醒接收数据的函数，它怎么来处理这些数据，因为串口的格式是：起始位+数据位+奇偶校验位+停止位。怎么过滤掉不需要的数据。__

​	__采用什么中断呢？__继续使用串口的中断处理函数吗，串口的RDEN中断是：当移位寄存器中的数据__存到__数据寄存器中，数据可读时，产生接收数据可读中断。现在我们是用IO口模拟，也就是说，我们不再使用关于串口的寄存器，我们是直接操作IO口的，相应的，读取数据，我们是直接来读取IO口的状态。如果使用串口的中断，来读取IO口的数据，将会引发错误。因为当串口的接收中断被触发时，IO口的电平变化早就过去了。

​	这个时候，我们从串口的数据格式入手：没有数据出现的时候，TX和RX线都是高电平，当开始传输信息时，先是起始信号：将高电平变成低电平，完成一次电平跳变，这时，我们就可以想到外部中断。因为外部中断的触发方式有两种：上升沿触发，下降沿触发。

​	在这里，我们也发现了，串口的开始信号就是下降沿，我们使用外部中断，下降沿触发中断。

​	好，到这里，接收的时机，我们已经有了，然后就是数据的处理，首先，起始信号，我们不要，跟在后边的8个信号波形是我们需要的信息。如果是LSB发送模式，字长为八位，那么第八位就是奇偶校验位，如果我们不开启奇偶校验位，默认为低电平。剩下的七位就是我们的数据位，这七位组成的数据完全够我们使用。0-127，可表示128个字符。最后的停止位就是将低电平拉高，结束一个字节的发送。所以我们要获取的信息就是起始位后边紧跟的八位数据。

​	那么，我们怎么来获取这八个位呢？

​	这个时候，波特率就来了，它是发送方和接收方共同约定的一个时间点。

​	那么在波形上是怎么体现的呢？

​	通过逻辑分析仪得知：从起始信号的下降沿开始，低电平持续一个波特率倒数。然后开始传输第一个数据信号，或低电平或高电平，持续一个波特率倒数。接着下一个信号，持续一个波特率倒数，直到一个串口格式数据发送结束，然后电平拉高。

​	那么什么时候去获取电平状态呢，最稳妥的方法就是在一个波特率倒数时间内，在它的二分之一处，去读取这个信号。然后到下一个二分之一处，中间的间隔时间正好是一个波特率倒数。到这里，数据处理，思路有了。

​	到这里，我们可以接收数据了，但是我的单片机没有屏幕，无法查看我接收数据是否正确，所以我需要写一个IO口模拟发送的函数。数据怎么模拟串口数据呢？按照上面提到的串口数据格式，将每一个字节都封装成一个串口数据，然后搭配延时函数发送出去，其中最重要的就是延时函数的准确性。

​	好了，到这里，思路基本理清了，然后就是搭建一个框架，先把函数之间调用流程搞好，然后再向函数中，填充代码，实现功能。

​	敲代码。。。。。。

​	第一次编译运行，居然无错误。小激动一下。

​	然后打开串口调试助手，无反应。

​	打开逻辑分析仪，抓波形，抓了半天，啥反应也没有。

​	怀疑：难道是没有进入中断？

​	排查：查看中断代码

​	结果：好吧，还真是代码问题，接收引脚是10号引脚，所以它对应的中断处理函数名是EXIT15_10_IRQHandler,而我写的是EXIT9_5_IRQHandler，明摆着就是进不去。

​	修改代码，编译运行。

​	现象：和刚才一模一样，神马反应也没有

​	怀疑：还是没有触发外部中断

​	排查：查看外部中断的注册代码

​	结果：查了半天，有个清除位操作错了，应该是 __&=__,我给整成__|=__,

​	修改代码，编译运行。

​	现象：没！动！静！

​	处理：在中断函数中添加亮灯代码，默认是关灯。

​	现象：灯亮了，中断进去了。但是没有数据发送。

​	排查：查看发送函数。

​	结果：代码好像没啥问题，怎么办，有了，在while循环中，直接改变发送引脚的电平状态。

​	修改代码，编译并下载。

​	现象：打开逻辑分析仪，抓波形，但是无反应，一直高电平。

​	排查：难道是GPIO初始化出错，不可能，led灯还闪这呢。

​		额。。。不过，为了放心，就认为它有错吧。去从头到尾查看一下PA10和PA9的初始化代码。

​	结果：别说，还真有错。在初始化PA9的代码中，模式配置中，led灯的输出配置的推挽输出，这里我给PA9配置的是复用功能的推挽输出，是之前配置串口寄存器用的。没有改这部分代码，直接拿来用了。

​	然后，小心翼翼的把PA9的模式配置成推挽输出。

​	修改代码，编译并下载。

​	现象：打开逻辑分析仪，终于出现变化了。PA9出现预期的波形变化。

​	解释：为什么会这样，推挽输出模式是GPIO引脚自己对外进行输出高低电平的

​										复用推挽输出是GPIO引脚挂载其他外设使用的模式，它不能自己单独对外输出。

​	接下来是恢复现场，重新回到模拟串口的氛围中，

​	编译并下载。

​	现象：逻辑分析仪，PA9的波形很乱。PA10如期给开发板发送数据。但是串口调试助手无反应。

​	原因：设置的发送条件没有改变，那就手动写死。

​	现象：串口助手出现乱码。成功出现数据。

​				同时打开调试助手，波形很乱。

​	处理：现在的重点就是中断处理函数的接收数据的问题了

​	排查代码，经过多次测试。多次修改延时函数和数据处理函数，终于成功。唯一的难点就是延时函数，延时无法精准。大到几百微秒，小到1到2微秒，由于，单片机的主频是百兆范围，无法做到延时纳秒。只能通过运算多余的指令来延时零点几微秒。

​	所以在计算不同波特率下，来延时不同的时间，很耗费时间，我做了好多方法，只确保在460800、115200和9600这三个波特率中，保证数据收发的准确性。

​	另外，有由于SysTick使用的是192M的时钟频率。在这个频率之下，我用的方式是可以。我需要再换其他的时钟频率再进行测试。

​                                                                                                                         2019年10月16日

​	今天，我尝试使用其他systemcoreclock，来测试模拟串口的发送，在115200的波特率下，我使用168M、176M、192M和200M的时钟可以保证准确的发送，如果是接收，只有192M的频率可以成功接收。

​	通过不停的用逻辑分析仪抓波形，发现，当我使用systemcoreclock的频率越高，中间的指令延时就越小，我的delayus的延时就可以越精准。当我使用的systemcoreclock频率越低，中间的指令延时就越长。而且越不好控制。同样的误差越大，使用的波特率就不能使用越大的波特率，越大的波特率对误差要求也就越小，到460800以上，误差基本都要控制到0到0.2微秒。稍微在大一点就不行了。而且，数据的波形也有延迟，尽管非常小，只有不到0.1微秒的误差，如果从起始位开始到停止位，每一个位都有波形变化。加起来就算0.1微秒，再加上延时函数，执行指令造成的误差，累加到最后几位，也是很客观的误差。所以在使用串口通信时，能使用寄存器就使用寄存器，实在不行，使用IO口模拟，串口的波特率不能太高，systemcoreclock的频率还不能太低，必须是高频。

​	另外，就是重新定义printf。

​	我在keil官网上找到这么一段描述：

Some C library functions use semihosting. If you use the libraries in a nonsemihosting environment, you must ensure that semihosting function calls are dealt with appropriately.

If you do not want to use semihosting, either:

- Remove all calls to semihosting functions.

- Re-implement the lower-level functions, for example, `fputc()`. You are not required to re-implement all semihosting functions. You must, however, re-implement the functions you are using in your application.

  You must re-implement functions that the C library uses to isolate itself from target dependencies. For example, if you use `printf()` you must re-implement `fputc()`. If you do not use the higher-level input/output functions like `printf()`, you do not have to re-implement the lower-level functions like `fputc()`.

- Implement a handler for all of the semihosting calls to be handled in your own specific way. One such example is for the handler to intercept the calls, redirecting them to your own nonsemihosted, that is, target-specific, functions.

  它的意思就是，如果要在单片机中使用C Libraries functional，而且不使用半主机环境，就必须重新定义fputc（）等低级别的函数。使printf（）这种高级别的函数成为特定的函数，也就是target-specific functional。

  关于串口重新定义的代码：

  ```c
  #pragma import(__use_no_semihosting)             
                   
  struct __FILE 
  { 
  	int handle; 
  
  }; 
  
  FILE __stdout;       
     
  _sys_exit(int x) 
  { 
  	x = x; 
  } 
   
  int fputc(int ch, FILE *f)
  {      
  	while((USART1->STS &0X40)==0)
  		continue;  
      USART1->DT = (u8) ch;      
  	return ch;
  }
  //第一句代码：#pragma import(__use_no_semihosting)  
  //keil官网上有解释：
  //IMPORT __use_no_semihosting is only required to be added to a single assembly source file. 
  //Similarly, #pragma import(__use_no_semihosting) is only required to be added to a single C source file. 
  //It is unnecessary to add these inserts to every single source file.
                                            /* 2019年10月17日  */
  ```

  

​	                                                                                                                                                      