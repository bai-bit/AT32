# SPI

​	SPI 是英语Serial Peripheral Interface的缩写，就是串行外围设备接口。

​	SPI是一种高t速的，全双工，同步的通信总线，并且在芯片的管脚上只占用四根线，节约了芯片的管脚。主要应用在EEPROM,FLASH,实时时钟，AD转换器，还有数字信号处理器和数字信号解码器之间。

​	SPI接口一般使用4条线通信：

​	MISO:主设备输入，从设备输出。

​	MOSI:主设备输出，从设备输入。

​	SCLK:时钟信号，由主设备产生。

​	CS：从设备片选信号，由主设备控制。

​	SPI的工作原理：

​	硬件上为4条线。

​	主机和从机都有一个串行移位寄存器，主机通过向它的SPI串行寄存器写入一个字节来发起一次传输。

​	串行移位寄存器通过MOSI信号线将字节传送给从机，从机也将自己的串行移位寄存器中的内容通过MISO信号线返回给主机，这样，两个移位寄存器中的内容就被交换了。

​	外设的写操作和读操作时同步完成的。如果只进行写操作，主机只需忽略接收到的字节；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。

​	工作原理已经出来了，很简单。接下来，介绍一下SPI的配置过程，首先先说明一下关键的配置位。

​	1、NSS引脚：分为外部NSS引脚和内部NSS引脚，外部NSS引脚是实实在在的硬件，一个GPIO口，用来产生一个片选信号。内部的NSS引脚是真正连接在SPI通信控制器上的。

​	他们之间还有其他的东西，这些东西是用来干什么的呢，为什么需要这些东西？

​	这是因为SPI的硬件结构只有四条线，片选信号只有一条，而从从设备却有可能有好多个，我想对他们逐个通信，而不是像开会、像广播那样，广而告之。我想私聊。很明显只有一条片选，无法实现这个功能，于是就出现用软件来控制片选信号。也就是我使用寄存器来直接控制内部的NSS引脚。这时，外部NSS引脚就用不到了，还能节省芯片的一个GPIO口。

​	那么中的这些东西都是什么呢？别着急，我一个一个来说：

​	首先第一个，是要不要开启软件从设备管理；第二个，是开启了软件从设备管理，它的内部NSS引脚的状态是什么值；第三个，如果是硬件控制，这个时候，外部的NSS引脚和内部NSS引脚就间接的连在了一起，中间有个寄存器，这个寄存器的作用是：要不要把内部NSS引脚的状态输出到外部NSS引脚上。如果不输出，就表示工作在多主模式；反之就是工作在单主模式。就是在一个SPI系统中，是一个主机还是有多个主机。

​	所以这中间需要三个寄存器来管理。

​	在AT32的手册中，SPI_CTRL1的第九位，名字叫SWNSSEN,软件从设备管理；看过它的说明，他的功能是选择硬件控制或者是软件控制。。SPI_CTRL1的第八位，ISS位，它的值来代表内部NSS的状态。SPI_CTRL2的第2位，NSSOE位，单主机或多主机模式。

​	说了这么多，总结一下，就是NSS这个东西，就是CS片选信号，当选择硬件来控制，直接操作对应GPIO口。如果是软件控制，只能通过一个寄存器来配置，这个寄存器就是上面说的ISS位。而且当一个由SPI通信接口的设备，主机和从机的时候，这个ISS位也是不一样的。当它位主机时，ISS位要设置为1，内部NSS引脚为高电平，用一个GPIO引脚使能从设备，开始数据传输。当它为从机时，ISS位要设置为0，内部NSS引脚为低电平，使能，开始数据传输。

​	2.CPHA和CPOL

​	CPHA称为时钟相位，CPOL称为时钟极性。这两个位在SPI_CTRL1中的第0位(CPHA)和第1位(CPOL)。这两个位可以组成四种时序关系，CPHA是决定在哪一个边沿采集数据，上升沿rising或者是下降沿falling。

​	CPOL是控制时钟线在空闲状态时的电平状态。为1时，时钟线在空闲状态时为高电平，为0时，时钟线在空闲状态时为低电平。

​	CPHA为0时，在时钟线的第一个边沿采集数据，数据在第一个时钟边沿被锁存，当它为1时，在时钟线的第二个边沿采集数据，数据在第二个时钟边沿采集数据。

​	3.数据帧格式

​	分为8为数据长度和16位数据长度。发送的顺序分为LSB和MSB。

​	4.状态标志位

​	状态标志位有好几个，可以通过查看SPI_STS寄存器的说明，不过最常用的就是三个，第7位，BSY位，忙标志位，第1位，发送缓冲为空，第0位，接收缓冲为空。

还有其他的配置比如波特率，CRC校验，模式配置（SPI模式或者是IIS模式），全双工或者是单工，使能SPI。

​	接下来，贴上代pi_init代码：

```c
//首先配置为缺省值。全是0
//然后根据自己的需要配寄存器
//配置的内容：数据的传输方向，全双工，8位数据帧，lsb的格式帧，分频系数256，主机模式，cpol = 0，cpha = 1，nss值，crc
//使能spi的时钟
//最后使能spi

	RCC->APB2EN |= 1 << 12;
	SPI1->CTRL2 &= ~SPI_CTRL2_MCLKP_3;
	SPI1->CTRL1 &= SPI_CR1_Mask;
	SPI1->CTRL1 |= (SPI_FULLDUPLEX | SPI_FRISTBIT_LSB | SPI_WORKMODE_Master | SPI_DATASIZE_8Bits |
							SPI_CPOL_LOW | SPI_CPHA_2EDGE | SPI_NSSSEL_SOFT | SPI_BAUDRATEPRESCALER );
	SPI1->I2SCTRL &= SPI_MODE_SEL;
	SPI1->CPOLY = 7;
	SPI1->CTRL1 |= CTRL1_SPIEN_SET;
```

初始化结束后，还不行，SPI是用来通信用的，所以我们还要加通信代码：

```c
//下面这个函数是一个判断标志位的函数
FlagStatus SPI_GetFlagStatus(SPI_Type *SPIx,uint16_t SPI_FLAG)
{
	if(SPIx->STS & SPI_FLAG)
		return SET;
	else
		return RESET;
}

//下面这几行代码就是实现数据传送的一个过程，可以把它单独定义一个函数，也可以放在main函数中。
		while(SPI_GetFlagStatus(SPI1,SPI_Flag_TX) == RESET);
		GPIO_PinWrite(HW_GPIOA,gpio_pin_4,0);
		SPI1->DT = data;
		while(SPI_GetFlagStatus(SPI1,SPI_Flag_BSY) == SET);
		GPIO_PinWrite(HW_GPIOA,gpio_pin_4,1);
		ch = SPI1->DT;
```

​	当然，SPI也有中断，也可以用中断来触发一次数据传输，这个就更简单了，配置相关的寄存器。使能触发条件。等待触发就好了。